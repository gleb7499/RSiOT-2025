# Лекция 17. Контейнеры

Коротко: зачем и где применяется. Контейнеры позволяют упаковать приложение с его зависимостями в переносимый образ, который одинаково работает в локальной среде, CI и облаке. Это база современных практик доставки (Docker, OCI) и оркестрации (Kubernetes).

## Результаты обучения

После лекции вы:

- поймёте, что такое контейнер/образ/реестр и чем контейнер отличается от виртуальной машины;
- напишете корректный Dockerfile и соберёте оптимальный многоступенчатый образ;
- подготовите `docker-compose` для локальной композиции сервисов;
- ознакомитесь с базовыми практиками безопасности и оптимизации образов;
- запустите контейнер, проверите логи, проброс портов, volume‑монтирование и healthcheck.

## Пререквизиты

- Базовые знания Linux и командной строки.
- Понимание процессов и сетей на уровне приложений (TCP/HTTP).
- Желательно: опыт с Git и CI/CD.

## Введение: картина мира

Контейнер — это песочница для приложения (процесс + filesystem), использующая ядро хоста. Образ — неизменяемый шаблон файловой системы и инструкций запуска. Реестр — место хранения образов (Docker Hub, GitHub Container Registry, приватные реестры). Контейнеры облегчают переносимость, CI/CD и масштабирование.

## Основные понятия и терминология

- Image: неизменяемый артефакт (слои) по спецификации OCI.
- Container: запущенный экземпляр образа (процесс + namespace).
- Registry: хранилище образов (push/pull).
- Dockerfile: инструкция сборки образа.
- Volume: постоянное хранилище данных для контейнера.
- Healthcheck: проверка состояния контейнера.
- Multi‑stage build: оптимизация размера образа за счёт сборки в отдельном этапе.

## Пошаговое освоение темы

### Подтема 1. Простейший Dockerfile и сборка

Определения:

- FROM: базовый образ.
- RUN: запуск команды во время сборки.
- COPY/ADD: копирование файлов в образ.
- CMD/ENTRYPOINT: команды запуска контейнера.

```dockerfile
# file: Dockerfile
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .

FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app .
EXPOSE 3000
HEALTHCHECK --interval=30s --timeout=3s CMD wget -qO- http://localhost:3000/health || exit 1
CMD ["node", "server.js"]
```

Пояснение к примеру: многоступенчатая сборка — сначала устанавливаем зависимости, затем копируем только необходимые файлы в финальный образ, что уменьшает размер и убирает dev‑артефакты.

Проверка:

- Соберите образ: `docker build -t myapp:latest .`;
- Запустите: `docker run --rm -p 3000:3000 myapp:latest`;
- Откройте `http://localhost:3000/health` — ожидайте ответ 200.

Типичные ошибки: хранение секретов в Dockerfile; использование `latest` в production; отсутствие `.dockerignore` → включение лишних файлов в образ.

### Подтема 2. Docker run: опции, тома и сети

Определения:

- -v/--mount: примонтировать volume для хранения данных.
- --rm: удалить контейнер после остановки.
- --network: подключение к пользовательской сети.

```bash
# Запуск контейнера с volume и пользовательской сетью
docker network create app-net
docker run -d --name redis --network app-net redis:7-alpine
docker run -d --name myapp --network app-net -p 3000:3000 \
	-v $(pwd)/data:/app/data \
	--env-file .env myapp:latest
```

Пояснение к примеру: сеть `app-net` позволяет контейнерам общаться по имени; volume сохраняет данные между перезапусками; `.env` держит переменные конфигурации (не хранить секреты в repo).

Проверка: `docker ps` покажет оба контейнера; `docker logs myapp` — логи приложения; `docker exec -it myapp sh` — войти внутрь контейнера.

Типичные ошибки: использование host networking без причины; хранение секретов в `.env` в репозитории; отсутствие ограничения ресурсов (memory/cpu).

### Подтема 3. docker-compose для локальной разработки

Определения:

- Service: логический компонент в `docker-compose`.
- Depends_on: порядок запуска сервисов (не заменяет проверки readiness).

```yaml
# file: docker-compose.yml
version: '3.8'
services:
	redis:
		image: redis:7-alpine
		networks:
			- app-net

	myapp:
		build: .
		ports:
			- "3000:3000"
		environment:
			- REDIS_HOST=redis
		depends_on:
			- redis
		networks:
			- app-net

networks:
	app-net:
		driver: bridge
```

Пояснение к примеру: `docker-compose up` запускает несколько сервисов локально; `depends_on` гарантирует старт redis до myapp, но для надёжности лучше реализовать retry/healthcheck в приложении.

Проверка: `docker compose up --build` и `docker compose ps`; попробуйте остановить redis — приложение должно корректно обработать недоступность.

Типичные ошибки: полагаться на `depends_on` как на проверку готовности; отсутствие healthchecks; хранение больших данных в volume без очистки.

### Подтема 4. Оптимизация образов и best practices

Определения:

- Layer caching: повторное использование слоёв при сборке.
- .dockerignore: исключение лишних файлов из контекста сборки.
- Minimal base image: alpine/distroless для уменьшения размера.

Короткий вывод: располагайте часто меняющиеся файлы (код) после менее изменчивых (install deps) в Dockerfile; используйте multi‑stage; минимизируйте лишние пакеты и скрывайте сборочные инструменты из финального образа.

Типичные ошибки: установка build‑tools в финальном образе; COPY . до RUN npm ci → ломает кэш и увеличивает build time.

### Подтема 5. Безопасность контейнеров

Определения:

- Least privilege: запускать процессы с непривилегированными пользователями.
- Image scanning: проверка образов на уязвимости (Trivy, Clair).
- Immutable images: неизменяемые образы — не правьте контейнер вручную.

```bash
# Пример сканирования (Trivy)
trivy image myapp:latest

# Запуск контейнера с непользовательским пользователем и ограничением ресурсов
docker run --user 1000:1000 --memory=256m --cpus=0.5 myapp:latest
```

Пояснение к примеру: сканирование даёт отчет по CVE; запуск под nonroot и ограничение ресурсов повышают безопасность и устойчивость.

Проверка: выполните `trivy image` и исправьте зависимости; проверьте, что контейнер не запускается с root внутри (`docker exec id`).

Типичные ошибки: использование `--privileged` без необходимости; хранение секретов внутри образа; запуск приложений как root.

### Подтема 6. Контейнеры в CI/CD и реестры образов

Определения:

- Registry: Docker Hub, GitHub Container Registry, GitLab Registry, приватные Nexus/Harbor.
- Tagging: semantic tagging (semver, commit sha, latest).
- Signed images: подпись образов для проверки целостности (cosign).

Пример CI (псевдо‑конфигурация):

```yaml
# GitHub Actions (упрощённо)
name: Build and push
on: [push]
jobs:
	build:
		runs-on: ubuntu-latest
		steps:
			- uses: actions/checkout@v4
			- name: Build image
				run: docker build -t ghcr.io/ORG/myapp:${{ github.sha }} .
			- name: Push
				run: |
					echo ${{ secrets.GHCR_TOKEN }} | docker login ghcr.io -u USER --password-stdin
					docker push ghcr.io/ORG/myapp:${{ github.sha }}
```

Пояснение к примеру: CI собирает образ и пушит в приватный реестр с tag по SHA; в проде используйте immutable tags и подпись образов.

Проверка: проверьте, что образ появился в реестре и доступен по тегу SHA.

Типичные ошибки: перезаписывать `latest` в production; хранение реестровых ключей в коде; неочищенные локальные образы в CI runner.

## Разбор типичных ошибок и анти‑паттернов

- Хранение секретов в образе или `.env` в репо.
- Запуск контейнеров как root.
- Игнорирование healthchecks и readiness probes (в Kubernetes).
- Слишком большие образы → долгие деплои и повышенный трафик.
- Ручные правки контейнера в проде вместо сборки нового образа.

## Вопросы для самопроверки

1. Чем контейнер отличается от виртуальной машины?
2. Почему важен multi‑stage build?
3. Какие преимущества даёт `.dockerignore`?
4. Как защитить секреты при использовании контейнеров?
5. Что такое healthcheck и зачем он нужен?
6. Как уменьшить размер образа?
7. Почему нельзя полагаться на `depends_on` как на readiness?
8. Как ограничить ресурсы контейнера при запуске?
9. Для чего нужен image registry и какие есть практики tag‑ирования?
10. Как выполнять сканирование образов и что исправлять в результате?
11. Что означает immutable image в CI/CD?
12. Как управлять томами данных для контейнеров?
13. Почему важно запускать процессы в контейнере под непривилегированным пользователем?
14. Какие риски при использовании `--privileged`?
15. Какие метрики/логи важно собирать с контейнеров?

## Краткий конспект (cheat‑sheet)

- Dockerfile: порядок инструкций влияет на кэширование; используйте multi‑stage для уменьшения размера.
- Build: `docker build -t name:tag .` → Push: `docker push registry/name:tag`.
- Run: `docker run -d -p HOST:CONTAINER --name name --network net -v host:container image`.
- Compose: `docker compose up --build` для локальной разработки.
- Security: nonroot user, scan images (Trivy), не хранить секреты в образах.

## Дополнительно

Глоссарий:

- OCI: Open Container Initiative — спецификация образов и runtime.
- Layer: слой файловой системы образа.
- Registry: хранилище образов.
- Healthcheck: механизм проверки состояния контейнера.
- Multi‑stage: сборка в нескольких этапах.

Полезные ссылки:

- Docker docs: [https://docs.docker.com](https://docs.docker.com)
- OCI spec: [https://opencontainers.org](https://opencontainers.org)
- Trivy: [https://aquasecurity.github.io/trivy/](https://aquasecurity.github.io/trivy/)

## Быстрая практика

```bash
# 1) Собрать образ
docker build -t myapp:local .

# 2) Запустить сервисы через compose
docker compose up --build -d

# 3) Проверить логи и статус
docker compose logs -f
docker ps

# 4) Сканировать образ
trivy image myapp:local || true

# 5) Очистить ресурсы
docker compose down --volumes --remove-orphans
docker image prune -f
```

Ожидаемый результат: образ собран и запущен локально, логи отображаются, scan выдаёт предупреждения/ok, ресурсы очищены.

Критерии качества: все обязательные секции присутствуют; определения перед примерами; у каждого примера есть «Пояснение», «Проверка», «Типичные ошибки»; корректные fenced‑блоки и форматирование.

# Лекция 02. Контейнеры
План:
- cgroups/namespaces, образы и слои
- Docker best practices, registry, SBOM
- Безопасность образов (scanning, least privilege)
Практика: сборка минимального и безопасного образа.
Чтение: Docker docs; NIST контейнерная безопасность (обзор).

## Материал для лекции
- Линукс‑примитивы: namespaces, cgroups; контейнер ≠ VM.
- Образы: слои, union FS, multi‑stage build, reproducible builds.
- Сеть контейнеров: bridge/host/none, порт‑маппинг, DNS.
- Безопасность: non‑root, capabilities, seccomp/AppArmor, read‑only FS.
- SBOM, сканирование образов, обновления баз уязвимостей.
- Регистри: теги, неизменяемость, подписи (cosign), политика pull.
- Ресурсы: requests/limits, cgroup‑ограничения, OOM.

### Практический пример: multi‑stage Dockerfile и HEALTHCHECK
Короткий пример для Go‑сервиса (аналогично для Node/Python):

```dockerfile
# syntax=docker/dockerfile:1
FROM golang:1.22-alpine AS build
WORKDIR /src
COPY . .
RUN CGO_ENABLED=0 go build -o app ./cmd/app

FROM gcr.io/distroless/base-debian12
USER 65532:65532
WORKDIR /app
COPY --from=build /src/app /app/app
EXPOSE 8080
HEALTHCHECK --interval=30s --timeout=3s CMD ["/usr/bin/curl","-sf","http://127.0.0.1:8080/health"]
ENTRYPOINT ["/app/app"]
```

Советы:
- Минимизируйте базовые образы (alpine/distroless), отключайте root, ограничивайте capabilities.
- Кешируйте зависимости (COPY go.mod/go.sum перед COPY . или npm ci). 
- Включайте SBOM/сканирование (syft/grype, Trivy) в CI.
