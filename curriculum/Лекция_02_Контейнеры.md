# Лекция 02. Контейнеры

## Цели и результаты обучения
- Понять, что такое контейнеры и чем они отличаются от виртуальных машин.
- Разобраться, как работают namespaces, cgroups и слои образов.
- Научиться собирать образы (Dockerfile), запускать контейнеры и работать с сетью/томами.
- Освоить базовые практики безопасности, сканирование, лимиты ресурсов и Compose.

## План лекции
- Что такое контейнеры и чем они отличаются от виртуальных машин
- Как контейнеры работают внутри: namespaces, cgroups, слои образов
- Базовые команды Docker: pull/run/build/push, теги и дайджесты
- Dockerfile — по шагам: FROM, RUN, COPY, CMD/ENTRYPOINT, USER, HEALTHCHECK
- Сеть и хранилище: порты, volume и bind‑mount, переменные окружения
- Безопасность на практике: non‑root, capabilities, seccomp/AppArmor, read‑only
- Best practices: multi‑stage, кэширование, минимальные образы, SBOM и сканирование
- Реестр образов: теги, неизменяемость, подписи
- Ресурсы и устойчивость: лимиты, перезапуски, логи, диагностика

## Требования и софт
- Windows с Docker Desktop и WSL2; PowerShell.
- Браузер для проверки сервисов; опционально Trivy/Syft для безопасности.

---

## 1. Зачем контейнеры и что это вообще такое
Docker — платформа для разработки, упаковки и запуска приложений в контейнерах. Контейнер — это «упакованное приложение» с зависимостями, запущенное изолированно на общей ОС.

Проще всего думать так: контейнер — это «упакованное приложение» + его зависимости, которое запускается изолированно на общей ОС. В отличие от виртуальной машины (VM):
- VM имеет свою гостевую ОС и гипервизор; контейнер делит ядро хоста с другими контейнерами.
- Контейнеры запускаются быстрее, занимают меньше места, их проще переносить.

Типичные кейсы: микросервисы, CI/CD, быстрые окружения для разработки, повторяемые деплои.

Термины:
- image (образ) — «шаблон» файловой системы + метаданные; из образа создают контейнеры.
- container (контейнер) — «запущенный образ» с собственным процессом/процессами.
- layer (слой) — образ состоит из слоёв (copy‑on‑write), что ускоряет загрузку и кэширует сборку.
- registry (реестр) — хранилище образов (Docker Hub, GitHub Container Registry, GitLab, ECR и т.д.).
- tag (тег) — удобная метка версии (например, myapp:1.0.0), digest — неизменяемый идентификатор (sha256:...).

Примечание: «образ» неизменяем (read‑only). Изменения во время работы приложения попадают в верхний «записываемый» слой контейнера.

### Виртуальная машина и гипервизор: что и зачем

- Виртуальная машина (VM) — программная «эмуляция компьютера», в которой запускается собственная гостевая ОС, её драйверы, системные библиотеки и ваше приложение. Внутри ВМ есть виртуальные устройства: CPU, сеть, диски и т.д.
- Гипервизор — софт/прошивка/железо, на котором работают ВМ. Он располагает и изолирует ресурсы хоста (CPU, RAM, I/O) между гостями.
- Типы гипервизоров:
	- Hosted (type‑2): поверх ОС хоста (например, VirtualBox/VMware Workstation на Windows/macOS). Плюсы — совместимость с железом обеспечивает ОС хоста; минус — дополнительный слой даёт накладные расходы и ниже производительность.
	- Bare‑metal (type‑1): установлен прямо «на железе» (например, ESXi, Hyper‑V Server). Плюсы — выше производительность, масштабируемость и стабильность; минус — ограниченная совместимость (драйверы внутри гипервизора).
- Зачем нужен гипервизор: ВМ несут полную гостевую ОС, и гипервизор — это платформа, которая управляет их запуском, изоляцией и справедливым распределением ресурсов хоста между гостями.

### Контейнер: точнее о природе (сравнение с VM)

- Контейнер реализует виртуализацию на уровне операционной системы: изолируется пользовательское пространство (user space), а ядро у контейнеров общее с хостом.
- По ощущениям контейнер похож на ВМ: у него есть собственное пространство процессов, можно выполнять команды от root внутри контейнера, есть отдельный сетевой интерфейс и IP‑адрес, можно настраивать маршруты и правила iptables, монтировать файловые системы и т.п.
- Ключевое отличие: в контейнере нет «гостевой ОС» — контейнеры разделяют ядро хоста между собой.
- Следствия: контейнеры стартуют быстрее и потребляют меньше ресурсов; нельзя сменить версию ядра внутри контейнера; уровень безопасности зависит от ядра хоста, поэтому важны корректные настройки namespaces/cgroups и профилей AppArmor/SELinux/seccomp.

Ключевая разница с контейнерами: ВМ виртуализируют аппаратный уровень (у каждой ВМ — своя гостевая ОС), контейнеры — уровень ОС (общие ядро и драйверы; изолируется user space).

Иллюстрации:

![VM (freeCodeCamp)](./Лекция_02_Контейнеры_assets/fcc_vm.png)

![Containers (freeCodeCamp)](./Лекция_02_Контейнеры_assets/fcc_container.png)

![Контейнеры vs ВМ](./Лекция_02_Контейнеры_assets/containers_vs_vm.svg)

![Слои образа и union FS](./Лекция_02_Контейнеры_assets/layers_and_unionfs.svg)

![Namespaces и cgroups](./Лекция_02_Контейнеры_assets/namespaces_cgroups.svg)

### Наглядные метафоры (для интуитивного понимания)

Чтобы быстрее «схватить» идею, полезны простые сравнения:
- Пластиковый контейнер → контейнер Docker: можно «сложить» приложение с зависимостями, легко переносить между машинами; есть «крышки/интерфейсы» — порты и команды CLI.
- Живой организм → контейнер как экземпляр: образы «оживают» при запуске; контейнеры рождаются, работают и «умирают».
- Программа → контейнер это запущенная программа, которую можно стартовать/останавливать/исследовать.
- Пицца → процесс сборки/запуска: рецепт = Dockerfile, ингредиенты = слои образа, духовка = Docker Engine/платформа, «повернуть ручку» = docker run, готовая пицца = работающий контейнер. Это помогает запомнить: image — неизменяемый шаблон, container — запущенный экземпляр.

Источник для метафор и базовых концепций: «Изучаем Docker, часть 1: основы» (Habr, RUVDS).

## 2. Как это работает внутри (простыми словами)

- namespaces изолируют «видимость»:
	- pid (процессы), net (сеть), mnt (файловые системы), ipc, uts (hostname), user (UID/GID).
- cgroups ограничивают «сколько можно»: CPU, память, количество процессов и т.д.
- union/overlay файловая система даёт «слои» образов и тонкий writable‑слой контейнера.

Итог: кажется «как отдельная машина», но на самом деле это процессы хоста с изоляцией.

Инструменты: Docker (CLI/Engine), containerd (runtime), Podman/Buildah (rootless), nerdctl, Docker Desktop (для Windows/macOS), WSL2.

## 3. Быстрый старт в Windows (PowerShell)

Предварительно: установите Docker Desktop и включите WSL2 (официальная инструкция). Проверьте:

```powershell
docker version
docker run --rm hello-world
```

Полезные базовые команды:

```powershell
docker pull nginx:alpine          # скачать образ
docker images                      # список образов
docker run -d -p 8080:80 nginx    # запустить в фоне и пробросить порт 8080->80
docker ps                          # список работающих контейнеров
docker logs <container>            # логи
docker stop <container>; docker rm <container>  # остановить и удалить
docker rmi nginx                   # удалить образ
```

О тегах: latest — просто тег по умолчанию, не «самая свежая». Для стабильности фиксируйте версии или используйте digest.

## 4. Dockerfile — инструкция для сборки образа

Dockerfile — это сценарий сборки: по инструкциям создаётся образ.

Частые инструкции:
- FROM — базовый образ (например, python:3.12-slim)
- WORKDIR — рабочая директория внутри образа
- COPY/ADD — копирование файлов в образ (ADD умеет распаковывать архивы/URL — используйте Copy по возможности)
- RUN — выполнить команду при сборке (установка пакетов, билд)
- ENV — переменные окружения
- EXPOSE — документирует порт (не открывает его автоматически)
- USER — под каким пользователем запускать приложение
- CMD/ENTRYPOINT — что запускать по умолчанию в контейнере
- HEALTHCHECK — как оценивать «живость» контейнера

#### 4.1 Dockerfile: основы и слои образа

- FROM задаёт базовый образ — стартовый слой. Часто используют официальные: `python`, `ubuntu`, `alpine` и др.
- Поверх базового слоя добавляются новые слои: системные утилиты, библиотеки, зависимости приложения и сам код. Порядок инструкций влияет на кэширование и скорость повторной сборки.
- Пример: образ для ML может добавлять NumPy/Pandas/Scikit‑learn отдельным слоем перед копированием кода, чтобы кэш не инвалидировался при правках исходников.
- Важно: слои образа неизменяемы (read‑only). «Записываемый» слой появляется только во время запуска контейнера — это runtime‑слой, куда попадают изменения файловой системы при работе процесса.
- Следствие: чтобы итоговый образ был компактным и безопасным, используйте multi‑stage, чистите кеши менеджеров пакетов и фиксируйте версии зависимостей.

#### 4.2 CMD vs ENTRYPOINT, exec vs shell, ENV vs ARG

- CMD задаёт команду по умолчанию (может быть переопределена при `docker run ... <cmd>`). ENTRYPOINT задаёт «непереопределяемую» базовую команду, к которой CMD добавляет аргументы.
- Предпочитайте exec‑форму (JSON‑массив): `CMD ["node","server.js"]` — так не нужна оболочка `/bin/sh`, корректно передаются сигналы.
- Shell‑форма: `CMD node server.js` — запускает через оболочку, удобна для простых сценариев, но хуже для сигналов.
- ENV — переменные окружения на этапе runtime; ARG — переменные только во время сборки (доступны в Dockerfile, но не в контейнере по умолчанию).

Шаблон для объединения ENTRYPOINT + CMD:

```dockerfile
ENTRYPOINT ["/app/app"]  # бинарь/скрипт
CMD ["--help"]           # аргументы по умолчанию
```

Подробнее и примеры:

- Как переопределяется при запуске (`docker run`):
	- Если в Dockerfile только CMD — команда в `docker run <image> <новая_команда>` полностью заменяет CMD.
	- Если есть ENTRYPOINT (exec‑форма) и CMD — всё, что вы допишете в конце `docker run <image> <args>`, попадёт как аргументы к ENTRYPOINT (CMD заменится этими аргументами).
	- Полностью заменить ENTRYPOINT можно флагом `--entrypoint`.

- Exec vs Shell формы:
	- Exec (JSON): запускает процесс напрямую как PID 1. Сигналы (SIGTERM/SIGINT) доходят до процесса. Не выполняет расширений оболочки (`*`, `$VAR`).
	- Shell: выполняет через `/bin/sh -c` (или `cmd /S /C` на Windows). Удобно для пайпов/переменных, но сигналы может «ловить» оболочка, а не ваше приложение. Для сервисов лучше exec‑форма или `--init`.

- PID 1 и сигналы:
	- Процесс PID 1 в контейнере отвечает за обработку сигналов и «сбор» зомби‑процессов. Если вы запускаете шелл‑скрипт, делайте в конце `exec "$@"`, чтобы заменить оболочку вашим процессом.
	- Альтернатива: использовать `docker run --init ...` (tini) или включить tini как ENTRYPOINT.

- Типовые паттерны:
	1) CLI‑утилита:
		 ```dockerfile
		 ENTRYPOINT ["mycli"]
		 CMD ["--help"]
		 ```
		 Запуск: добавляйте подкоманды/флаги — они станут аргументами `mycli`.

	2) Долгоживущий сервис:
		 ```dockerfile
		 CMD ["gunicorn","app:app","-b","0.0.0.0:8080"]
		 ```
		 Здесь ENTRYPOINT не обязателен. Для передачи своих флагов при запуске указывайте всю команду.

	3) ENTRYPOINT + дефолтные флаги:
		 ```dockerfile
		 ENTRYPOINT ["python","app.py"]
		 CMD ["--port","8080"]
		 ```
		 Запуск с переопределением: `docker run image --port 9090` (CMD заменится).

- Полезные команды (PowerShell):
	```powershell
	# Полностью заменить ENTRYPOINT при запуске
	docker run --rm --entrypoint /bin/sh image -c "env"

	# Добавить свои аргументы к ENTRYPOINT (заменит CMD)
	docker run --rm image --verbose --limit 10

	# Заменить CMD, если ENTRYPOINT не задан
	docker run --rm image python -V
	```

- Частые ошибки и как их избегать:
	- Ожидать, что `docker run image bash` «всегда» заменит команду. Если есть ENTRYPOINT, без `--entrypoint` это лишь аргумент для ENTRYPOINT.
	- Использовать shell‑форму для сервисов и терять корректную обработку сигналов. Лечится exec‑формой или `--init`.
	- Полагаться на подстановку переменных оболочки в exec‑форме. Делайте `ENV` и передавайте параметры как отдельные аргументы.

#### 4.3 Секреты и .dockerignore

- Не храните секреты в Dockerfile и образах. Используйте менеджеры секретов и переменные окружения/средства оркестратора.
- Добавьте `.dockerignore`, чтобы исключить лишние файлы (`.git`, `node_modules`, `__pycache__`, логи и пр.). Это ускоряет сборку и уменьшает образ.

### Пример 1: минимальный Python‑сервис (Flask)

Файлы приложения:

```python
# app.py
from flask import Flask
app = Flask(__name__)

@app.get("/")
def index():
		return "Hello from container!\n"

@app.get("/health")
def health():
		return {"status": "ok"}

if __name__ == "__main__":
		app.run(host="0.0.0.0", port=8080)
```

```text
# requirements.txt
flask==3.0.3
```

```dockerfile
# Dockerfile
FROM python:3.12-slim
WORKDIR /app

# Установка зависимостей отдельно, чтобы лучше работал кэш
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt

# Копируем исходники
COPY . .

# Безопаснее запускать не от root
RUN useradd -u 10001 -r -s /sbin/nologin appuser \
		&& chown -R appuser:appuser /app
USER 10001

EXPOSE 8080
HEALTHCHECK --interval=30s --timeout=3s CMD curl -fsS http://127.0.0.1:8080/health || exit 1

CMD ["python", "app.py"]
```

Сборка и запуск:

```powershell
docker build -t myflask:1.0 .
docker run --rm -p 8080:8080 myflask:1.0
```

Откройте http://localhost:8080

### Пример 2: Node.js (Express)

```javascript
// server.js
const express = require('express');
const app = express();
app.get('/', (req, res) => res.send('Hello from Node!\n'));
app.get('/health', (req, res) => res.json({status: 'ok'}));
app.listen(8080, '0.0.0.0');
```

```json
// package.json
{
	"name": "my-node",
	"version": "1.0.0",
	"private": true,
	"scripts": {"start": "node server.js"},
	"dependencies": {"express": "4.19.2"}
}
```

```dockerfile
# Dockerfile
FROM node:22-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --omit=dev

FROM node:22-alpine
WORKDIR /app
COPY --from=deps /app/node_modules /app/node_modules
COPY . .
RUN adduser -D -u 10001 appuser && chown -R appuser:appuser /app
USER 10001
EXPOSE 8080
HEALTHCHECK --interval=30s --timeout=3s CMD wget -qO- http://127.0.0.1:8080/health || exit 1
CMD ["npm","start"]
```

Сборка и запуск:

```powershell
docker build -t mynode:1.0 .
docker run --rm -p 8080:8080 mynode:1.0
```

### .dockerignore

Добавьте файл `.dockerignore`, чтобы в образ не попадали лишние файлы:

```text
.git
node_modules
__pycache__
*.log
Dockerfile*
*.md
```

## 5. Multi‑stage build и минимальные образы

Идея: собирать (build) и запускать (runtime) в разных слоях/образах. Это уменьшает размер и поверхность атаки.

Go/Node уже показаны в двух стадиях. Для Python можно использовать slim/ubi‑минимальные образы. В проде часто применяют distroless — там нет shell/менеджеров пакетов, только рантайм.

Важно:
- Чем меньше образ, тем меньше уязвимостей и быстрее доставка.
- Не храните сборочные артефакты и кеши в финальном образе.
- Для воспроизводимости фиксируйте версии и используйте lock‑файлы (requirements.txt, package-lock.json).

## 6. Сеть контейнеров (коротко)

- По умолчанию используется сеть bridge. Порт‑маппинг: `-p 8080:80` — с хоста 8080 идёт в контейнер на 80.
- Режимы: bridge/host/none. В Kubernetes используются поды и CNI — дальше по курсу.
- DNS внутри контейнера настраивается Docker’ом; имена сервисов в одной пользовательской сети (user‑defined network) резолвятся автоматически.

Создать сеть и подключить контейнеры:

```powershell
docker network create mynet
docker run -d --name web --network mynet nginx:alpine
```

Проверяем доступность:

```powershell
# Локально с хоста (bridge + порт‑маппинг)
curl http://localhost:8080

# Межконтейнерное обращение в одной сети (используем имя службы)
docker run --rm --network mynet curlimages/curl:8.9.1 curl -s http://web
```

Как это работает (очень коротко): Docker в режиме bridge настраивает NAT и правила iptables; `-p` пробрасывает порт с интерфейса хоста на порт контейнера.

## 7. Хранилище: volumes и bind‑mount

- bind‑mount — «примонтировать» папку хоста в контейнер (удобно для разработки).
- volume — управляемое Docker хранилище (переносимо между контейнерами, не привязано к пути хоста).

Пример: отдать свою статическую страницу через Nginx.

```powershell
# В PowerShell путь можно подставить так:
# - Используйте ${PWD} (Windows) или путь вида C:\Users\... (в кавычках)

echo "<h1>Hello Nginx</h1>" > index.html
docker run --rm -d -p 8080:80 -v "${PWD}\index.html":/usr/share/nginx/html/index.html:ro nginx:alpine
```

Откройте http://localhost:8080

Когда что использовать:
- Разработка: bind‑mount (видите изменения файлов сразу).
- Прод: именованные тома (управляемость, переносимость, права).

Именованный том:

```powershell
docker volume create mydata
docker run --rm -d -p 8080:80 -v mydata:/var/www/html nginx:alpine
```

Подсказка по путям в Windows:
- В PowerShell экранируйте обратные слеши и используйте кавычки: `"${PWD}\file.txt"`.
- В WSL2 удобнее использовать Linux‑пути и оболочку bash.

## 8. Конфигурация и секреты

- ENV/--env: передавайте конфигурацию через переменные окружения.
- Не кладите секреты (пароли, ключи) в образ/репозиторий. Используйте Secret Manager/возможности оркестратора. В Docker Compose есть `secrets` (для Linux).
- Для локального dev можно использовать `--env-file .env`.

## 9. Безопасность на практике (минимум, который стоит делать всегда)

- USER: не запускайте процессы от root.
- Capabilities: «урежьте права» (по умолчанию Docker уже урезает, но можно ещё меньше):

```powershell
docker run --cap-drop ALL --cap-add NET_BIND_SERVICE ...
```

- Read‑only FS: запретить запись в файловую систему контейнера, кроме смонтированных томов:

```powershell
docker run --read-only -v mydata:/data ...
```

- Seccomp/AppArmor/SELinux: дополнительные профили изоляции (по умолчанию Docker включает базовый seccomp). Для продакшена изучите профили под вашу ОС.
- Rootless/Podman: запуск без привилегий root на хосте — снижает риски.
- Регулярные обновления базовых образов и зависимостей.

Сканирование уязвимостей и SBOM:
- Trivy: `trivy image myflask:1.0`
- Syft: `syft myflask:1.0 -o json > sbom.json`
- Следите за актуальностью баз уязвимостей и false positives (оценка по CVSS, наличие фикс‑версий).

Подпись образов (supply chain):
- Cosign: подпишите образ и проверяйте подписи в CI/CD.

## 10. Реестры образов

- Локально: Docker Hub (публичный/частный), GitHub Container Registry, GitLab, AWS ECR и т.д.
- Теги: используйте семантические версии и неизменяемые теги. Можно фиксировать запуск по digest:

```powershell
docker run nginx@sha256:<хеш>
```

- Политика pull: кто и откуда тянет образы; права доступа; зеркала.

## 11. Ресурсы, устойчивость и диагностика

- Лимиты:

```powershell
docker run --memory 256m --cpus 0.5 --pids-limit 100 myflask:1.0
```

- Политики перезапуска: `--restart=on-failure:3` или `always` (осторожно в dev).
- HEALTHCHECK: даёт оркестратору понять, когда контейнер «нездоров».
- Логи: `docker logs -f <id>`; направляйте структурированные логи в stdout/stderr.
- Диагностика: `docker inspect`, `docker exec -it <id> /bin/sh` (если shell есть), `docker events`.

## 12. Docker Compose (мини‑оркестратор для dev)

Пример `compose.yaml`: веб + Redis.

```yaml
services:
	web:
		build: .
		ports:
			- "8080:8080"
		environment:
			- REDIS_HOST=redis
		depends_on:
			- redis
	redis:
		image: redis:7-alpine
```

Запуск:

```powershell
docker compose up --build -d
docker compose ps
docker compose logs -f
docker compose down -v
```

Подсказка: Compose читает `.env` и подставляет переменные (`${NAME}`). Секреты (Linux): `secrets:`.

## 13. Типичные проблемы и как их диагностировать

- Порт занят: «bind: address already in use» — проверьте `Get-NetTCPConnection` в PowerShell, смените порт.
- OOM (Killed): не хватает памяти — задайте `--memory`, оптимизируйте приложение.
- Права доступа к файлам (особенно на Windows/WSL): проверьте владельца/права, используйте совместимые пути.
- DNS/внешняя сеть недоступна: проверьте настройки Docker Desktop/прокси.
- Раздутый образ: включите multi‑stage, чистите кеши, выбирайте slim/distroless базу.

---

## 14. Шпаргалка команд (PowerShell)

```powershell
# Скачивание/запуск/инспекция
docker pull alpine:3.20
docker run --rm -it alpine:3.20 sh
docker ps -a; docker images
docker inspect <id-or-name>

# Сборка/теги/публикация
docker build -t user/myapp:1.0 .
docker tag user/myapp:1.0 user/myapp:latest
docker login; docker push user/myapp:1.0

# Ресурсы/безопасность
docker run --rm --memory 256m --cpus 0.5 --pids-limit 100 user/myapp:1.0
docker run --rm --read-only --cap-drop ALL user/myapp:1.0

# Тома/сети
docker volume ls; docker network ls
docker volume inspect mydata; docker network inspect mynet
```

---

## 15. FAQ для новичков

- Нужно ли всегда `EXPOSE`? — Нет, это документация. Открытие порта делает `-p`.
- Почему образ большой? — Тяжёлый базовый образ, кеши, сборочные артефакты; используйте slim/alpine, multi‑stage, чистку кешей.
- Чем отличаются ENV и ARG? — ENV доступно в рантайме контейнера, ARG — только на этапе сборки.
- Почему контейнер «видит» только свои процессы? — Из‑за namespaces (pid). Это и есть изоляция.
- Можно ли менять версию ядра в контейнере? — Нет, контейнер делит ядро хоста.

---

## 16. Мини‑квиз (самопроверка)

1) Что виртуализирует ВМ, а что — контейнер?
2) Зачем нужен multi‑stage build?
3) Чем отличаются CMD и ENTRYPOINT?
4) Когда лучше использовать volume, а когда bind‑mount?
5) Что делает `-p 8080:80`?

Ответы (кратко):
1) ВМ — аппаратный уровень (гостевая ОС); контейнер — уровень ОС (user space, общее ядро).
2) Уменьшает образ, исключает сборочные артефакты из рантайма, ускоряет кэширование.
3) ENTRYPOINT — базовая команда; CMD — аргументы/дефолтная команда, может переопределяться.
4) Dev — bind‑mount (горячие правки); prod — volume (надёжность, переносимость).
5) Пробрасывает порт хоста 8080 на порт 80 контейнера (NAT в bridge‑сети).

## Практикум (пошагово, с вариантами для новичков)

1) Hello Nginx (5 минут):
- Создайте `index.html` с текстом «Привет, контейнеры!»
- Запустите Nginx с bind‑mount и проверьте страницу в браузере.

2) Свой сервис (Python или Node) — 20–30 минут:
- Подготовьте исходники (см. примеры выше), `.dockerignore` и `Dockerfile`.
- Соберите образ: `docker build -t myapp:dev .`
- Запустите: `docker run --rm -p 8080:8080 myapp:dev`
- Добавьте USER (non‑root), HEALTHCHECK, зафиксируйте версии зависимостей.

3) Минимизация и лимиты — 10 минут:
- Попробуйте alpine/slim, проверьте размер образа `docker images`.
- Запустите с лимитами `--memory`, `--cpus`; посмотрите поведение под нагрузкой.

4) (Опционально) Сканирование и SBOM — 10 минут:
- Установите Trivy/Syft локально, просканируйте образ и сформируйте SBOM.

5) (Опционально) Compose:
- Описать web + redis в `compose.yaml`, поднять, проверить работу по имени хоста `redis`.

### Критерии успешности
- Образ собирается без ошибок, контейнер отвечает на `/` и `/health`.
- Запуск без root; размер образа разумный; логика сборки кэшируется.
- Понимание, где хранить данные (volume), как пробрасывать порты и переменные.

---

## Домашнее задание

- Контейнеризируйте маленький сервис (любой стек), добавьте HEALTHCHECK, non‑root, `.dockerignore`.
- Настройте Docker Compose для вашего сервиса + зависимости (например, БД или Redis).
- Попробуйте разные базовые образы (slim/alpine) и сравните размер/скорость.
- (Опция) Просканируйте образ и приложите отчёт о найденных уязвимостях и принятых мерах.

## Рекомендуемое чтение и ссылки

- Docker Docs: Images, Containers, Networking, Volumes, Compose
- Play with Docker (онлайн‑песочница)
- OWASP Docker Security Cheat Sheet
- NIST SP 800‑190 (Application Container Security Guide)
- Trivy, Syft, Cosign — официальные репозитории и документация

---
