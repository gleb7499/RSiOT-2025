# Лекция 01. Введение в распределенные системы
План:
- Определения, мотивация, fallacies of distributed computing
- Модели взаимодействия/отказов; синхронность vs асинхронность
- Метрики: доступность, задержка, пропускная способность
Практика: разбор инцидента из реального сервиса по публичному пост-мортему.
Чтение: Kleppmann гл.1; SRE book гл.1.

## Материал для лекции

### 1. Что такое распределенная система
**Теория:**  
Распределенная система — это совокупность независимых вычислительных узлов (серверов, процессов), которые взаимодействуют по сети для решения общей задачи.  
Узлы могут быть физически удалены друг от друга, находиться в разных дата-центрах, странах, работать на разных платформах.  
Взаимодействие происходит через передачу сообщений, вызовы API, обмен данными.  
Частичные отказы — норма: сбой одного узла не должен приводить к остановке всей системы.  
Примеры: поисковые системы (Google, Яндекс), соцсети (Facebook, VK), банковские сервисы, облачные платформы (AWS, Azure, GCP).  
Архитектура распределенных систем строится с учетом масштабируемости, отказоустойчивости, независимости компонентов.

### 2. Мотивация распределения
**Теория:**  
- Масштабирование по нагрузке: рост числа пользователей и запросов требует увеличения вычислительных ресурсов. Горизонтальное масштабирование — добавление новых узлов для обработки большего объёма данных. Пример: микросервисы, каждый из которых масштабируется независимо.
- Масштабирование по данным: большие объёмы информации невозможно хранить на одном сервере. Шардирование — разбиение данных на части, распределение по узлам. Пример: распределённые базы данных (Cassandra, MongoDB).
- Геораспределение: снижение задержек для пользователей из разных регионов, репликация данных между дата-центрами. Пример: CDN — контент доставляется из ближайшего узла.
- Доступность и отказоустойчивость: устранение единой точки отказа (SPOF), репликация сервисов и данных, автоматическое переключение на резервные узлы. Пример: отказ одного сервера не влияет на работу всего сайта.
- Независимая эволюция подсистем: разделение на микросервисы, независимая разработка и деплой. Пример: команда занимается только сервисом оплаты, другая — только каталогом товаров.
- Экономика: использование облачных ресурсов по требованию (on-demand), оптимизация затрат, автоматическое масштабирование.

### 3. Fallacies of Distributed Computing (Заблуждения)
**Теория:**  
- Сеть всегда надёжна: на практике возможны потери пакетов, разрывы соединений, недоступность узлов. Пример: сбой маршрутизатора, перегрузка канала.
- Задержка пренебрежимо мала: задержка может быть значительной, особенно между регионами или при перегрузке. Важно учитывать хвостовые значения (p99).
- Пропускная способность бесконечна: ограничения на скорость передачи данных, особенно при массовых операциях. Пример: лимиты облачных провайдеров, ограничения на межрегиональный трафик.
- Сеть безопасна: возможны атаки, перехват, подмена данных, DDoS. Необходимо использовать шифрование, аутентификацию.
- Топология стабильна: узлы могут появляться и исчезать, маршруты меняться. Пример: автоматическое масштабирование, сбои оборудования.
- Один администратор: часто множество команд, ролей, зон ответственности.
- Транспорт бесплатен: трафик между регионами/облаками стоит денег, особенно для больших данных.
- Среда однородна: разные ОС, железо, версии ПО, сетевые настройки.
Эти заблуждения приводят к ошибкам в проектировании и эксплуатации распределённых систем.

### 4. Модели взаимодействия
**Теория:**  
- Запрос-ответ (RPC/REST/gRPC): синхронные вызовы, клиент ожидает ответ. Преимущества — простота, предсказуемость. Недостатки — чувствительность к задержкам, сбоям. Пример: REST API для получения информации о пользователе.
- Асинхронные сообщения (очереди, pub/sub): отправка сообщений без ожидания немедленного ответа, обработка в фоне. Преимущества — устойчивость к сбоям, возможность масштабирования. Недостатки — сложность отладки, задержки доставки. Пример: заказ поступает в очередь, обработка происходит позже.
- Сериализация данных: форматы — JSON (читаемость), Protobuf/Avro (эффективность, строгие схемы). Важно — совместимость схем при обновлениях, миграциях.
- Идемпотентность операций: повторный запрос не должен приводить к ошибке или дублированию результата. Пример: повторная оплата заказа не должна списывать деньги дважды.
Взаимодействие между узлами требует продуманной архитектуры, обработки ошибок, ретраев, таймаутов.

### 5. Модели отказов
**Теория:**  
- Crash-stop: узел полностью выходит из строя, не восстанавливается. Пример: физический сбой сервера.
- Crash-recovery: узел временно недоступен, затем восстанавливается. Важно — корректное восстановление состояния.
- Пропуски сообщений: потеря, дублирование, изменение порядка доставки. Требуется — подтверждение доставки, дедупликация.
- Сетевые разделения (partitions): часть узлов не может связаться с другими. Важно — проектировать систему так, чтобы она работала при разделениях (CAP).
- Византийские ошибки: узел ведет себя произвольно (например, злонамеренно). Критично для финансовых систем, блокчейнов.
Модели отказов определяют требования к архитектуре, репликации, обработке ошибок.

### 6. Временные модели
**Теория:**  
- Синхронная модель: известны максимальные задержки, легко строить алгоритмы. На практике редко встречается.
- Асинхронная модель: задержки не ограничены, сложнее гарантировать согласованность. Требует дополнительных механизмов для обнаружения сбоев.
- Частично синхронная модель: задержки ограничены, но не всегда. Более реалистична для реальных систем.
- Логические часы (Лэмпорт/векторные): позволяют отслеживать причинно-следственный порядок событий без точного времени. Пример: определение порядка операций в распределённой базе данных.
Временные модели влияют на алгоритмы репликации, консенсуса, согласованности.

### 7. Базовые метрики и цели
**Теория:**  
- Доступность: процент времени, когда система работает корректно (например, 99.99%). Важно учитывать не только время, но и качество работы (ошибки, деградации).
- MTTR (Mean Time To Recovery): среднее время восстановления после сбоя. Чем меньше MTTR, тем выше надёжность.
- SLI (Service Level Indicator): измеряемый показатель качества (например, задержка ответа, процент успешных запросов).
- SLO (Service Level Objective): целевое значение SLI (например, 95% запросов быстрее 100мс).
- SLA (Service Level Agreement): договорные обязательства перед клиентом, штрафы за нарушение.
- Задержки: p50/p95/p99 — медиана и хвостовые значения, важны для пользовательского опыта. Пример: если p99 задержка > 1с, пользователи будут недовольны.
- Пропускная способность: количество запросов/операций в секунду (RPS/QPS). Важно для высоконагруженных систем.
- Утилизация: загрузка CPU, памяти, сети. Перегрузка приводит к деградации качества.
Метрики позволяют оценивать качество работы системы, выявлять узкие места, планировать развитие.

### 8. Практические принципы надежности
**Теория:**  
- Таймауты: ограничение времени ожидания ответа, предотвращение зависаний. Важно — выбирать таймауты с запасом, учитывать хвостовые задержки.
- Дедлайны: общий лимит времени для цепочки запросов (например, запрос пользователя + все внутренние вызовы).
- Ретраи с backoff+джиттер: повторные попытки с увеличением интервала и случайным сдвигом для предотвращения перегрузки. Пример: экспоненциальный backoff с джиттером для повторных запросов к API.
- Ограничение скорости (rate limiting): защита от перегрузки, предотвращение отказа системы. Пример: лимит 100 запросов в секунду на пользователя.
- Circuit breaker: автоматическое отключение проблемного компонента при сбоях. Позволяет системе восстанавливаться без полной деградации.
- Bulkhead: изоляция компонентов для предотвращения распространения сбоя. Пример: разделение потоков обработки по типам задач.
- Идемпотентность: безопасные повторные запросы, предотвращение дублирования операций.
Эти практики повышают устойчивость системы к сбоям, позволяют быстро восстанавливаться.

### 9. Масштабирование и оценка
**Теория:**  
- Закон Литтла (L = λW): среднее число запросов в системе = интенсивность потока × среднее время обработки. Применяется для оценки очередей, задержек, пропускной способности.
- Вертикальное масштабирование: увеличение ресурсов одного узла (CPU, память, диск). Ограничено физическими возможностями.
- Горизонтальное масштабирование: добавление новых узлов, распределение нагрузки. Требует балансировки, репликации, шардинга.
- Кэширование: снижение нагрузки на хранилища, ускорение ответов. Пример: Redis, Memcached, CDN.
- Очереди: сглаживание пиков нагрузки, асинхронная обработка задач. Пример: RabbitMQ, Kafka.
Масштабирование — ключ к устойчивости и производительности распределённых систем.

### 10. Архитектурные компромиссы
**Теория:**  
- CAP-теорема: невозможно одновременно обеспечить согласованность (Consistency), доступность (Availability) и устойчивость к разделениям (Partition Tolerance). При сетевом разделении приходится выбирать между согласованностью и доступностью. Пример: банковская система (важна согласованность), соцсеть (важна доступность).
- PACELC: при отсутствии разделения — выбор между задержкой (Latency) и согласованностью (Consistency). Важно для глобальных систем с высокой задержкой между регионами.
- Координация — узкое место: глобальные блокировки, транзакции — источник задержек и точка отказа. Минимизировать использование координации, использовать eventual consistency там, где допустимо. Пример: кэширование, асинхронные события.
Архитектурные компромиссы определяют стратегию развития и эксплуатации распределённых систем.

---

**Вопросы для обсуждения:**
- Почему нельзя просто "добавить серверов" для решения всех проблем?
- Какие реальные инциденты происходили из-за неверных предположений о сети?
- Как выбрать между согласованностью и доступностью для конкретного сервиса?
- Какие метрики важнее всего для вашего проекта?

**Практика:**
- Разберите публичный пост-мортем инцидента (например, сбой в облаке, массовый outage).
- Определите, какие fallacies сыграли роль, какие метрики были нарушены, какие архитектурные решения могли бы предотвратить проблему.
  - Пример: определение порядка операций в распределённой базе данных.

### 7. Базовые метрики и цели
- Доступность:
  - Процент времени, когда система работает корректно (например, 99.99%).
  - Важно: учитывать не только время, но и качество работы (ошибки, деградации).
- MTTR (Mean Time To Recovery):
  - Среднее время восстановления после сбоя.
  - Чем меньше MTTR, тем выше надёжность.
- SLI (Service Level Indicator):
  - Измеряемый показатель качества (например, задержка ответа, процент успешных запросов).
- SLO (Service Level Objective):
  - Целевое значение SLI (например, 95% запросов быстрее 100мс).
- SLA (Service Level Agreement):
  - Договорные обязательства перед клиентом, штрафы за нарушение.
- Задержки:
  - p50/p95/p99 — медиана и хвостовые значения, важны для пользовательского опыта.
  - Пример: если p99 задержка > 1с, пользователи будут недовольны.
- Пропускная способность:
  - Количество запросов/операций в секунду (RPS/QPS).
  - Важно для высоконагруженных систем.
- Утилизация:
  - Загрузка CPU, памяти, сети.
  - Перегрузка приводит к деградации качества.

### 8. Практические принципы надежности
- Таймауты:
  - Ограничение времени ожидания ответа, предотвращение зависаний.
  - Важно: выбирать таймауты с запасом, учитывать хвостовые задержки.
- Дедлайны:
  - Общий лимит времени для цепочки запросов (например, запрос пользователя + все внутренние вызовы).
- Ретраи с backoff+джиттер:
  - Повторные попытки с увеличением интервала и случайным сдвигом для предотвращения перегрузки.
  - Пример: экспоненциальный backoff с джиттером для повторных запросов к API.
- Ограничение скорости (rate limiting):
  - Защита от перегрузки, предотвращение отказа системы.
  - Пример: лимит 100 запросов в секунду на пользователя.
- Circuit breaker:
  - Автоматическое отключение проблемного компонента при сбоях.
  - Позволяет системе восстанавливаться без полной деградации.
- Bulkhead:
  - Изоляция компонентов для предотвращения распространения сбоя.
  - Пример: разделение потоков обработки по типам задач.
- Идемпотентность:
  - Безопасные повторные запросы, предотвращение дублирования операций.

### 9. Масштабирование и оценка
- Закон Литтла (L = λW):
  - Среднее число запросов в системе = интенсивность потока × среднее время обработки.
  - Применяется для оценки очередей, задержек, пропускной способности.
- Вертикальное масштабирование:
  - Увеличение ресурсов одного узла (CPU, память, диск).
  - Ограничено физическими возможностями.
- Горизонтальное масштабирование:
  - Добавление новых узлов, распределение нагрузки.
  - Требует балансировки, репликации, шардинга.
- Кэширование:
  - Снижение нагрузки на хранилища, ускорение ответов.
  - Пример: Redis, Memcached, CDN.
- Очереди:
  - Сглаживание пиков нагрузки, асинхронная обработка задач.
  - Пример: RabbitMQ, Kafka.

### 10. Архитектурные компромиссы
- CAP-теорема:
  - Невозможно одновременно обеспечить согласованность (Consistency), доступность (Availability) и устойчивость к разделениям (Partition Tolerance).
  - При сетевом разделении приходится выбирать между согласованностью и доступностью.
  - Пример: банковская система (важна согласованность), соцсеть (важна доступность).
- PACELC:
  - При отсутствии разделения — выбор между задержкой (Latency) и согласованностью (Consistency).
  - Важно для глобальных систем с высокой задержкой между регионами.
- Координация — узкое место:
  - Глобальные блокировки, транзакции — источник задержек и точка отказа.
  - Минимизировать использование координации, использовать eventual consistency там, где допустимо.
  - Пример: кэширование, асинхронные события.

---

**Вопросы для обсуждения:**
- Почему нельзя просто "добавить серверов" для решения всех проблем?
- Какие реальные инциденты происходили из-за неверных предположений о сети?
- Как выбрать между согласованностью и доступностью для конкретного сервиса?
- Какие метрики важнее всего для вашего проекта?

**Практика:**
- Разберите публичный пост-мортем инцидента (например, сбой в облаке, массовый outage).
- Определите, какие fallacies сыграли роль, какие метрики были нарушены, какие архитектурные решения могли бы предотвратить проблему.
