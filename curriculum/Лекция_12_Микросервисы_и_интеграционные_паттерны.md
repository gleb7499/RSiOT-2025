# Лекция 12. Микросервисы и интеграционные паттерны
План:
- Границы сервисов, контракты, API Gateway
- Sync vs async, событийные архитектуры
- Service mesh: Istio/Linkerd (обзор)
Практика: контрактные тесты для API.
Чтение: Microservices patterns; Istio docs (overview).

## Материал для лекции
- Границы сервисов: bounded contexts, независимое развертывание.
- Проектирование API: версионирование, обратная совместимость, эволюция.
- Синхронное vs асинхронное взаимодействие; choreography vs orchestration.
- API Gateway/BFF: троттлинг, аутентификация, агрегация.
- Service discovery, health-checks, registry (Consul/etcd).
- Паттерны устойчивости и eventual consistency в микросервисах.
- Анти‑паттерны миграции: распределённый монолит, чатти‑связность.

---

## Заголовок и контекст
Почему интеграционные паттерны критичны: от границ сервисов зависит автономия команд, масштаб и надёжность. Выбор sync/async, gateway, mesh влияет на задержки, стоимость и наблюдаемость.

## Результаты обучения
- Определять границы сервисов и их контракты.
- Выбирать sync/async взаимодействие для кейсов.
- Применять API Gateway/BFF и паттерны устойчивости.
- Понимать базовые возможности service mesh.

## Пререквизиты
- Базовые знания HTTP/REST и событийных систем.
- Опыт работы с контейнерами/Kubernetes полезен.

## Введение: картина мира
Микросервисы — это не только разбиение на процессы, но и грамотные интеграции: как сервисы общаются, эволюционируют и остаются устойчивыми при сбоях. Часто гибрид: запрос‑ответ для критичных путей, события для связности и интеграций.

## Основные понятия и терминология
Определения:
- **Bounded Context**: граница модели предметной области; внутри — согласованные термины и инварианты.
- **Contract (API)**: формальный интерфейс (HTTP/gRPC/schema), обеспечивающий совместимость.
- **BFF (Backend For Frontend)**: слой API, адаптированный под конкретные клиенты (mobile/web).
- **Service Mesh**: сетевой слой для сервис‑к‑сервису коммуникаций (mTLS, retries, routing).

## Пошаговое освоение темы

### Подтема 1. Границы сервисов и контракт‑переговоры
Определения:
- **Версионирование API**: управление изменениями интерфейса (URI/заголовки/schema evolution).
- **Backward Compatibility**: способность новой версии обслуживать старых клиентов.
- **Contract Tests**: проверки соответствия реализации контракту клиента/поставщика.

Мини‑пример (OpenAPI фрагмент):
```yaml
openapi: 3.0.3
info:
	title: Orders API
	version: 1.2.0
paths:
	/v1/orders:
		get:
			responses:
				'200':
					content:
						application/json:
							schema:
								$ref: '#/components/schemas/OrderList'
```
Пояснение: явное версионирование пути, описание контрактов через схемы.
Проверка: валидировать спецификацию (`spectral`, `openapi-cli`) и сгенерировать клиент.
Типичные ошибки:
- ломающие изменения без версии;
- несогласованность схемы и фактического ответа.

### Подтема 2. Sync vs Async, событийные интеграции
Определения:
- **Sync (запрос‑ответ)**: клиент ожидает немедленного ответа.
- **Async (события)**: взаимодействие через брокер, отложенная обработка.
- **Choreography**: реактивная логика распределена между участниками.
- **Orchestration**: центральный управляющий процесс.

Мини‑пример (событийный контракт — JSON Schema):
```json
{
	"$schema": "https://json-schema.org/draft/2020-12/schema",
	"title": "OrderCreated",
	"type": "object",
	"properties": {
		"orderId": { "type": "string" },
		"total": { "type": "number" }
	},
	"required": ["orderId", "total"]
}
```
Пояснение: событие `OrderCreated` с обязательными полями; используется в брокере.
Проверка: валидировать событие перед публикацией; потребители проверяют совместимость при эволюции.
Типичные ошибки:
- смешивать команды и события;
- отсутствие политики совместимости схем.

### Подтема 3. API Gateway и BFF
Определения:
- **Rate Limiting**: ограничение частоты запросов.
- **Authentication/Authorization**: проверка и контроль доступа (JWT/OAuth2).
- **Aggregation**: объединение ответов нескольких сервисов.

Мини‑пример (Nginx API Gateway — троттлинг):
```nginx
limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
server {
	location /api/ {
		limit_req zone=api burst=20 nodelay;
		proxy_pass http://backend;
	}
}
```
Пояснение: ограничивает запросы до 10 r/s с очередью burst; защищает бэкенд от перегрузки.
Проверка: нагрузочное тестирование `wrk`/`hey` — убедиться в 429 при превышении.
Типичные ошибки:
- транзит JWT без проверки подписи;
- отсутствие агрегации, многократные чаты к бэкендам.

### Подтема 4. Паттерны устойчивости: Circuit Breaker, Retry, Timeout
Определения:
- **Circuit Breaker**: размыкание цепи при сбоях для защиты системы.
- **Retry with Backoff**: повтор с задержкой.
- **Timeout**: лимит времени ожидания.

Мини‑пример (псевдо):
```plaintext
if failures > threshold then open breaker; else closed
request -> timeout(500ms) -> retry(3, exponential)
```
Пояснение: при частых ошибках запросы сразу отклоняются, давая сервису восстановиться.
Проверка: симулировать сбои; измерить снижение латентности и ошибки "fast‑fail".
Типичные ошибки:
- бесконечные ретраи без предела;
- слишком большие таймауты → каскадные задержки.

### Подтема 5. Service Discovery и Health Checks
Определения:
- **Discovery**: поиск доступных инстансов сервиса (Consul/etcd/K8s DNS).
- **Health Check**: проверка готовности/живости (`/health`, `/ready`).

Мини‑пример (Kubernetes probes):
```yaml
readinessProbe:
	httpGet:
		path: /ready
		port: 8080
livenessProbe:
	httpGet:
		path: /health
		port: 8080
```
Пояснение: отделяет готовность к обслуживанию от живости процесса.
Проверка: уберите зависимости — readiness должен провалиться, liveness оставаться успешным.
Типичные ошибки:
- один общий эндпоинт для всего;
- отсутствие таймаутов/порогов у проверок.

### Подтема 6. Service Mesh: обзор
Определения:
- **mTLS**: взаимная TLS‑аутентификация между сервисами.
- **Traffic Shaping**: канареечные релизы, маршрутизация по версиям.
- **Observability**: метрики/трейсинг/логи на сетевом уровне.

Мини‑пример (Istio VirtualService — канареечный релиз):
```yaml
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
spec:
	hosts:
		- orders
	http:
		- route:
				- destination:
						host: orders
						subset: v1
					weight: 80
				- destination:
						host: orders
						subset: v2
					weight: 20
```
Пояснение: трафик 80% на v1, 20% — на v2.
Проверка: метрики запросов по версиям; корректная обратная связь при ошибках новой версии.
Типичные ошибки:
- отсутствие политики сертификатов для mTLS;
- сложная маршрутизация без мониторинга.

---

## Разбор анти‑паттернов
- **Распределённый монолит**: сильная связность, общие БД, синхронные цепочки.
- **Чатти‑взаимодействие**: слишком много мелких запросов от BFF к множеству сервисов.
- **Жёсткие контракты**: отсутствие эволюции и гибкости.

## Вопросы для самопроверки (12)
1. Что такое bounded context и как его определить?
2. Зачем версионировать API и какие способы есть?
3. Когда выбрать событийную интеграцию вместо sync?
4. В чём различия оркестрации и хореографии?
5. Какие задачи решает API Gateway?
6. Как работает circuit breaker и когда его включать?
7. Чем отличается readiness от liveness?
8. Какие преимущества даёт mTLS?
9. Как измерять эффект канареечного релиза?
10. Что такое contract tests и зачем они?
11. Как избегать распределённого монолита?
12. В чём плюсы/минусы BFF?

## Краткий конспект (cheat‑sheet)
- Границы: bounded contexts, независимые схемы/БД.
- Контракты: OpenAPI/JSON Schema, версионирование, совместимость.
- Интеграции: sync для критичных путей, async для событий.
- Gateway/BFF: rate limit, auth, aggregation.
- Устойчивость: timeout, retry, breaker.
- Mesh: mTLS, канареечный трафик, observability.

## Глоссарий (10)
- Bounded Context, Contract, BFF, Sync/Async, Choreography, Orchestration, Circuit Breaker, Retry, Readiness, mTLS.

## Ссылки
- [Microservices Patterns](https://microservices.io/)
- [Istio Documentation](https://istio.io/latest/docs/)
- [OpenAPI Specification](https://spec.openapis.org/oas/latest.html)
