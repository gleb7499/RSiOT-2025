# Лекция 17. Сетевые основы для распределённых систем

Эта лекция — практическое введение в сетевые основы, необходимые для разработки и эксплуатации распределённых систем и сервисов в облаках.

План:

* Базовые протоколы: TCP/UDP, TLS, QUIC; HTTP/1.1 vs HTTP/2 vs HTTP/3
* RPC vs REST: контракты, gRPC и стриминг, сериализация (JSON/Protobuf)
* Надёжность: таймауты, ретраи, экспоненциальный backoff и джиттер, идемпотентность, hedging
* Сетевые характеристики в облаках: NAT, эфемерные порты, MTU/PMTU, балансировка L4/L7
* Диагностика: инструменты и метрики

Практика:

* Реализуем ретраи с экспоненциальной паузой и джиттером для REST и gRPC-клиента
* Считаем BDP и настраиваем параметры клиента
* Наблюдаем мультиплексирование HTTP/2/3 и влияние потерь

Чтение:

* RFC 9114 — HTTP/3
* RFC 9000 — QUIC
* gRPC docs — Overview, Deadlines/Timeouts
* Google SRE — Handling Overload (hedging, timeouts)

Цели (после лекции вы сможете):

* Объяснить различия TCP/UDP/QUIC и когда что выбирать
* Выбрать между REST и gRPC; описать контракты и обратную совместимость
* Настроить таймауты, ретраи и джиттер безопасно для сервиса
* Понять влияние MTU, NAT, балансировки и пула соединений на задержку и ошибки
* Применять инструменты диагностики (curl, grpcurl, pcap/wireshark)

---

## 0. Короткая история IP (и курьёзы IPv5)

Как мы дошли до жизни такой:

# Короткая история IP

## 1970‑е: ARPANET и NCP — «до‑IP эпоха»

Тогдашний стек был не TCP/IP, а NCP (Network Control Program). Он обеспечивал соединения между хостами ARPANET, но был привязан к конкретной сети и плохо масштабировался.  
Переход на TCP/IP (официальный «флаг‑дэй» — 1 января 1983) позволил отвязать транспорт (TCP/UDP) от конкретной подсети и сделать межсетевую маршрутизацию «по‑взрослому».

## 1981: IPv4 (RFC 791). Классовая адресация A/B/C

Идея: делим адрес на «номер сети» и «номер узла» по фиксированным границам (классам).
- Class A: 0.0.0.0–127.255.255.255, сеть/8, до ~16 млн хостов на сеть.
- Class B: 128.0.0.0–191.255.255.255, сеть/16, до ~65 тыс. хостов.
- Class C: 192.0.0.0–223.255.255.255, сеть/24, до 254 хостов.
- D (224.0.0.0/4) — multicast, E (240.0.0.0/4) — «на будущее».

В реальности это оказалось неэффективно: компании, которым нужно, скажем, 500 хостов, часто вынуждены были брать «жирный» Class B на 65k адресов, а Class C с 254 хостами — тесен. Это ускоряло исчерпание адресов и раздувало таблицы маршрутизации.

## 1993: CIDR (RFC 1519) — гибкие префиксы /n

Ушли от классов, появилась произвольная маска: запись вида `192.0.2.0/27`, `10.0.0.0/12` и т. п.  
Дали жизнь VLSM (Variable Length Subnet Masking) и агрегированию маршрутов (route summarization), что уменьшило «взрыв» маршрутов в глобальной таблице.

Примеры:
- Разбить `192.168.100.0/24` на 8 подсетей по `/27`:  
  `192.168.100.0/27`, `192.168.100.32/27`, …, `192.168.100.224/27` (по 30 usable адресов каждая).
- Агрегация: вместо публикации 16 блоков `203.0.113.0/24 … 203.0.113.15/24` провайдер анонсирует один `203.0.112.0/20` (если адреса непрерывны).

## 1996: RFC 1918 — приватные диапазоны и повсеместный NAT

Частные сети: `10.0.0.0/8`; `172.16.0.0/12`; `192.168.0.0/16`. Эти адреса не маршрутизируются в интернете.  
NAT стал типовой практикой: множество внутренних адресов «прячутся» за одним/несколькими публичными.
- PAT (NAT Overload): множество внутренних сессий мапятся на один внешний IP с разными портами.
- Плюсы: экономия «белых» IPv4, базовая изоляция.
- Минусы: ломает end‑to‑end, осложняет p2p/VoIP, требует ALGs/UPnP/STUN/ICE.

Быстрый пример (Linux/iptables): интернет на `eth0`, LAN на `eth1` (`192.168.1.0/24`)
```bash
sysctl -w net.ipv4.ip_forward=1
iptables -t nat -A POSTROUTING -o eth0 -s 192.168.1.0/24 -j MASQUERADE
```

## 2011+: исчерпание IPv4 у IANA/RIR, CGNAT и «экономия»

В 2011 IANA выдала последние свободные /8 региональным интернет‑регистрам (RIR). Далее регионы переходили на «последние /8», пулы возвратов и т. п.  
Массово применяется CGNAT (Carrier‑Grade NAT). Для этого выделен `100.64.0.0/10` (RFC 6598), чтобы не путать с RFC1918.  
Рынок адресов: аренда/покупка/обмен блоков, строгие фильтрации, RPKI и очистка «грязных» анонсов.

## Параллельно готовили IPv6 (RFC 1883 → 2460 → 8200)

- 128‑бит адресация, много места, более простая агрегация маршрутов.
- SLAAC и NDP вместо ARP/DHCP‑only; широкое использование multicast (в IPv6 нет broadcast).
- Расширения заголовка через extension headers; IPsec задумывался «по умолчанию» (в итоге — «обязателен к реализации», но не к использованию).

---

## Про «IPv5»: что это было на самом деле

Это не «пропущенная версия» и не опечатка. Существовал экспериментальный Internet Stream Protocol:
- ST (Stream Protocol) и ST‑II/ST2+ (RFC 1190, RFC 1819) — протоколы для потоковой передачи с QoS/резервацией.
- Пакеты ST использовали номер версии IP 5 в своем собственном заголовке. Параллельно в реестре «Protocol Numbers» (поле Protocol в заголовке IPv4) значение 5 было зарезервировано за ST.

ST не стал массовым «новым IP», но «цифра 5» уже была занята/ассоциировалась с экспериментом, поэтому следующий универсальный интернет‑протокол назвали IPv6.

---

## Любопытные адреса IPv4 (с практическими ремарками)

### 127.0.0.0/8 — loopback
`127.0.0.1` — «localhost», тест сетевого стека без выхода в сеть:
```bash
ping 127.0.0.1
curl http://127.0.0.1:8080
```

### 0.0.0.0 — «неопределённый»/«все интерфейсы» (зависит от контекста)
- В маршрутах: `0.0.0.0/0` — default route.
- В сокетах: bind на `0.0.0.0` означает «слушать на всех интерфейсах».
```bash
# слушать на всех интерфейсах порт 8080
python -m http.server 8080 --bind 0.0.0.0
```
- В DHCP‑запросах может использоваться как исходный адрес, когда у хоста ещё нет IP.

### 169.254.0.0/16 — link‑local (APIPA)
Автовыдача при сбое DHCP. Хосты с такими адресами видят друг друга только в пределах L2‑сегмента.  
Пример: Windows показывает «Подключение по локальной сети — Автонастройка IPv4 169.254.x.y».

### 224.0.0.0/4 — multicast
- `224.0.0.5`/`224.0.0.6` — OSPF Hello/DR.
- `224.0.0.1` — все хосты в подсети; `224.0.0.251` — mDNS (UDP/5353); `224.0.0.9` — RIP v2.  
Обратите внимание: `224.0.0.x` — «link‑local scope», не маршрутизируются.

### 240.0.0.0/4 — Class E, «зарезервировано»
Исторически «на будущее». В интернете почти не используется, многие стеки/оборудование по умолчанию блокируют.

### 255.255.255.255 — локальный широковещательный (limited broadcast)
Уходит только в локальный сегмент, роутеры не пересылают.

### Дополнительно «для экзамена»:
- `100.64.0.0/10` — CGNAT (между абонентом и оператором), не путать с RFC1918.
- `192.0.2.0/24`, `198.51.100.0/24`, `203.0.113.0/24` — TEST‑NET‑ы для документации/примеров.
- `198.18.0.0/15` — тесты производительности между сетевыми устройствами.
- `172.16.0.0/12` — именно /12 (`172.16.0.0–172.31.255.255`), не весь `172.0.0.0/8`.

---

## IPv6 «в трёх строках» — и немного подробнее

### Представление адресов
- 128 бит, 8 групп по 16 бит в hex: `2001:0db8:0000:0000:0000:0000:0000:0001`

Сокращение:
- Убираем ведущие нули в группе: `2001:db8:0:0:0:0:0:1`
- Один раз можно заменить непрерывные нулевые группы на `::` → `2001:db8::1`

Примеры:
- Полный → краткий: `fe80:0000:0000:0000:02aa:00ff:fe9a:4ca2` → `fe80::2aa:ff:fe9a:4ca2`
- Краткий → полный: `fd12:3456:789a::1` → `fd12:3456:789a:0000:0000:0000:0000:0001`

### Ключевые префиксы
- `fe80::/10` — link‑local. Автогенерятся на каждом интерфейсе. Нужны для NDP/RA.
- `::1` — loopback (аналог `127.0.0.1`).
- `2000::/3` — глобальные unicast (то, что «в интернет»).
- `fc00::/7` (практически — `fd00::/8`) — ULA (аналог RFC1918 для внутренних систем).
- `ff00::/8` — multicast (в IPv6 нет broadcast; всё через multicast).
  - `ff02::1` — все узлы L2‑сегмента; `ff02::2` — все роутеры; `ff02::fb` — mDNS.

### SLAAC и NDP (вместо ARP)
Хост слушает Router Advertisements (RA), получает префикс (например, `2001:db8:1234:5678::/64`) и формирует адрес.

Интерфейсный идентификатор:
- Исторически EUI‑64 на основе MAC (вставка `ff:fe` и инверсия U/L бита).
- Сегодня чаще используются «privacy extensions» (RFC 4941/8981): рандомные IID, периодическая смена.

Duplicate Address Detection (DAD) проверяет уникальность адреса перед использованием.

### «Упрощенный заголовок» и расширения
Базовый заголовок фиксированной длины, остальные фичи — через extension headers (Routing, Fragment, AH/ESP, Destination Options).

### Что ещё важно знать на практике
В IPv6 нет NAT44. Для пересечения разных миров используются NAT64/DNS64, 464XLAT, DS‑Lite и т. п., но default‑подход — end‑to‑end.

Типичные команды:
```bash
# Показать IPv6-адреса интерфейсов
ip -6 addr

# Пинг петли
ping6 ::1

# Пинг link-local (нужно указать интерфейс!)
ping6 fe80::1%eth0

# Маршруты IPv6
ip -6 route
```

Примеры адресов:
- Глобальный: `2001:db8:1234:5678::10` (префикс `2001:db8::/32` зарезервирован для документации).
- ULA: `fd12:3456:789a::/48` → подсети `/64`: `fd12:3456:789a:1::/64`, `fd12:3456:789a:2::/64`…
- IPv4‑mapped: `::ffff:192.0.2.33` (используется стеками для совместимости).

---

## Набор мини‑примеров «на пальцах»

### Почему CIDR лучше классов
Нужно 2000 адресов. Классы: C мало, B слишком много. С CIDR можно взять `172.20.0.0/21` (2046 usable) — «впору».

### Что значит «слушать на всех интерфейсах»
```bash
# Слушать IPv4 на всех интерфейсах
nc -l -p 8080 -s 0.0.0.0

# Слушать IPv6 на всех интерфейсах (аналогично ::)
nc -l -p 8080 -6 -s ::
```

### APIPA в живой сети
Если сервер DHCP недоступен, две машины получат `169.254.x.y` и смогут пинговать друг друга в пределах одного коммутатора, но не выйдут в интернет.


## 1. Модели и уровни: OSI vs TCP/IP (быстрый ориентир)

Идея уровней — разделить ответственность: снизу передаём биты, сверху — смысл сообщений.

![Модель OSI — 7 уровней](./assets/Лекция_17_Сетевые_основы_для_РС/model_osi_2_1.jpg)

Иллюстрация TCP/IP-стека уровней:

![TCP/IP model layers — Wikimedia Commons](https://commons.wikimedia.org/wiki/Special:FilePath/Tcpip_vrstvy.svg)

Источник: Wikimedia Commons, файл «Tcpip_vrstvy.svg» (CC BY-SA 4.0)

Сопоставление:

* Прикладной: HTTP/1.1, HTTP/2, HTTP/3, gRPC, DNS
* Транспорт: TCP (надёжный поток), UDP (датаграммы), QUIC (надежность поверх UDP)
* Сетевой: IPv4/IPv6, ICMP, маршрутизация
* Канальный/Физический: Ethernet, Wi‑Fi, оптика, ARP, MTU

Ключевой термин: MTU (Maximum Transmission Unit) — максимальный размер кадра на канальном уровне. В интернете типичное MTU=1500 байт (Ethernet), в облаках встречается 9001 (jumbo) или ниже из‑за туннелей. Неправильный MTU → фрагментация, падение пропускной способности.

Иллюстрация: MTU, фрагментация и Path MTU Discovery (PMTUD):

![MTU и фрагментация IPv4 — пример (Wikimedia Commons)](https://commons.wikimedia.org/wiki/Special:FilePath/IPv4_Fragmentation_example_-en.svg)

Источник: Wikimedia Commons, «IPv4 Fragmentation example -en.svg» (CC BY-SA 4.0). Для PMTUD см. также RFC 1191/8201.

Дополнительно почитать и посмотреть визуализации:

* Cisco: Path MTU Discovery — <https://www.cisco.com/c/en/us/support/docs/ip/internet-control-message-protocol-icmp/200527-Path-MTU-Discovery.html>
* Cloudflare: PMTUD in practice — <https://blog.cloudflare.com/path-mtu-discovery-in-practice/>

---

## 2. TCP: надёжный поток, handshake и перегрузка

TCP даёт гарантированно упорядоченную доставку байтов и контроль потока/перегрузки.

### 2.1 Трёхстадийное рукопожатие (3-way handshake)

Иллюстрация: трёхстадийное рукопожатие TCP (3-way handshake)

![TCP 3-way handshake — Wikimedia Commons](https://commons.wikimedia.org/wiki/Special:FilePath/Tcp-handshake.svg)

Источник: Wikimedia Commons, файл «Tcp-handshake.svg» (CC BY-SA 4.0)

TLS добавляет шифрование поверх TCP (HTTP/1.1, HTTP/2), а в HTTP/3 используется QUIC без TCP.

### 2.2 Управление перегрузкой (очень кратко)

* Slow start: рост окна экспоненциально до потерь
* Congestion avoidance (AIMD): аддитивный рост, мультипликативное снижение
* Современные алгоритмы: CUBIC, BBR (оптимизирует под пропускную способность/задержку)

### 2.3 Окна, задержка и BDP

* RTT (round-trip time) — время туда‑обратно
* BDP (bandwidth‑delay product) ≈ пропускная способность × RTT
  Пример: 100 Mbps × 50 ms ≈ 0.1 Gbps × 0.05 s = 0.005 Gbit ≈ 0.625 MB. Чтобы «заполнить трубу», отправителю нужно иметь окно порядка 0.6–0.7 МБ.

### 2.4 Nagle vs Delayed ACK

* Nagle (по умолчанию в TCP): объединяет мелкие пакеты → меньше накладных расходов, но выше задержка для чатов/RPC
* Delayed ACK: подтверждения не мгновенные → может усугубить задержку вместе с Nagle
* Практика: для RPC с малыми сообщениями часто включают TCP_NODELAY (выключают Nagle)

Иллюстрация к взаимодействию Nagle и Delayed ACK: подходящих свободных изображений на Commons не найдено. См. пояснения в тексте и статью «Nagle's algorithm» на Wikipedia. При необходимости добавлю схему из другого свободного источника.

---

## 3. UDP и QUIC

UDP — лёгкий датаграммный протокол, без гарантии доставки/порядка. Полезен для:

* Стриминга, телеметрии, игр — когда потеря лучше задержки
* QUIC использует UDP как транспорт, реализуя надёжность и шифрование на своём уровне

QUIC (RFC 9000/9114):

* Шифрование и мультиплексирование потоков внутри одного соединения
* Быстрое установление (0‑RTT/1‑RTT), встроенная миграция соединения по IP
* Нет HOL‑блокировки на уровне транспорта (в отличие от TCP)

Иллюстрация: сравнение рукопожатий TCP+TLS и QUIC

![TCP vs QUIC handshake — Wikimedia Commons](https://commons.wikimedia.org/wiki/Special:FilePath/Tcp-vs-quic-handshake.svg)

Источник: Wikimedia Commons, файл «Tcp-vs-quic-handshake.svg» (CC BY-SA 4.0)

---

## 4. HTTP/1.1 vs HTTP/2 vs HTTP/3

Проблема HTTP/1.1 — head‑of‑line blocking и ограничение на параллелизм (6 соединений/хост в браузерах). HTTP/2 и HTTP/3 решают это по‑разному:

Иллюстрация: стек протоколов HTTP/1.1 vs HTTP/2 vs HTTP/3

![HTTP-1.1 vs. HTTP-2 vs. HTTP-3 protocol stack — Wikimedia Commons](https://commons.wikimedia.org/wiki/Special:FilePath/HTTP-1.1_vs._HTTP-2_vs._HTTP-3_Protocol_Stack.svg)

Источник: Wikimedia Commons, файл «HTTP-1.1_vs._HTTP-2_vs._HTTP-3_Protocol_Stack.svg» (CC BY-SA 4.0)

Дополнительно:

* ALPN (TLS) для выбора протокола (h2, h3)
* Server push (h2) устарел в браузерах, но полезен в некоторых backend‑сценариях

Практический вывод: для сервис‑к‑сервису чаще пользуемся HTTP/2 или HTTP/3 (если окружение поддерживает) — меньше соединений, лучше утилизация.

---

## 5. TLS 1.2/1.3 и безопасность трафика

TLS шифрует трафик и аутентифицирует сервер (и, при необходимости, клиента). Важные понятия:

* Сертификат, цепочка доверия, SNI (Server Name Indication)
* Рукопожатие TLS 1.3 быстрее (меньше RTT), поддерживает 0‑RTT (осторожно: идемпотентность!)
* Возобновление сессии снижает задержку

---

## 6. RPC vs REST и gRPC

REST — стиль взаимодействия поверх HTTP, часто с JSON. RPC — вызов удалённых процедур, чаще с бинарной сериализацией и строгим контрактом.

gRPC (поверх HTTP/2 или HTTP/3):

* Контракт в .proto (Protobuf), автогенерация клиентов/серверов
* Типы взаимодействия: unary, server‑streaming, client‑streaming, bidirectional
* Сильные стороны: компактность, скорость, сквозные «дедлайны» (deadlines)

Пример контракта:

```proto
syntax = "proto3";
package payments.v1;

service PaymentService {
  rpc CreatePayment(CreatePaymentRequest) returns (CreatePaymentResponse) {}
  rpc GetStatus(GetStatusRequest) returns (GetStatusResponse) {}
  rpc StreamUpdates(GetStatusRequest) returns (stream StatusEvent) {}
}

message CreatePaymentRequest {
  string idempotency_key = 1; // для безопасных ретраев
  int64 amount = 2;
  string currency = 3;
}

message CreatePaymentResponse { string payment_id = 1; }
message GetStatusRequest { string payment_id = 1; }
message GetStatusResponse { string state = 1; }
message StatusEvent { string state = 1; string at = 2; }
```

---

## 7. Сериализация: JSON vs Protobuf (и эволюция схем)

* JSON: человекочитаем, гибок, но «тяжёлый» и медленнее
* Protobuf: бинарный, компактный, быстрый; требуется схема (.proto)

Правила совместимости схем:

* Полям присваивайте стабильные номера; не переиспользуйте удалённые номера
* Новые поля делайте опциональными; старые клиенты их игнорируют
* Не меняйте типы/смыслы существующих полей без миграции

---

## 8. Надёжность: таймауты, ретраи, backoff, джиттер, идемпотентность, hedging

Три аксиомы клиента:

* Сеть ненадёжна
* Задержки и потери случайны
* Ретрии без идемпотентности опасны

Контракт операции:

* Идемпотентные методы (GET, PUT, DELETE, безопасные POST c idempotency‑key)
* Дедлайн (deadline) — общий крайний срок, который передаём вниз по стеку (gRPC)
* Лимиты на попытки, backoff с джиттером, отказ от ретраев при таймаутах сервера 5xx с long‑running

Виды джиттера (полезен для рассинхронизации наплывов):

* Full jitter: `sleep = rand(0, base * 2^n)`
* Equal jitter: `sleep = base * 2^(n-1) + rand(0, base * 2^(n-1))`
* Decorrelated jitter (AWS): `sleep = min(cap, rand(base, sleep*3))`

Иллюстрация к экспоненциальному backoff с джиттером: подходящих свободных диаграмм на Commons не найдено. См. статью AWS «Exponential Backoff and Jitter» и Wikipedia «Exponential backoff». При необходимости добавлю изображение из свободного источника.

Hedging (дублирование): отправляем вторую попытку раньше полного таймаута, но только если операция идемпотентна и сервис поддерживает «dedupe» по ключу.

---

## 9. Соединения, балансировка и облачные сети

* Пулы соединений: переиспользуйте TCP/TLS/QUIC соединения; ограничивайте размер пула
* Балансировка L4 (TCP/UDP) vs L7 (HTTP/gRPC):
  + L4 быстрее, L7 умеет маршрутизировать по путям/заголовкам
* Sticky sessions: закрепление клиента за бекендом; осторожно с отказоустойчивостью
* NAT и эфемерные порты: исходящие соединения используют порт 49152–65535; возможна «exhaustion» при высоком QPS
* MTU/PMTU: контролируйте размер сообщений; для gRPC/HTTP2 избегайте фрагментации

Иллюстрация: схема балансировки с NAT

![Load Balancing Cluster (NAT) — Wikimedia Commons](https://commons.wikimedia.org/wiki/Special:FilePath/Load_Balancing_Cluster_(NAT).svg)

Источник: Wikimedia Commons, файл «Load_Balancing_Cluster_(NAT).svg» (CC BY-SA 4.0)

Kubernetes кратко:

* ClusterIP/NodePort/LoadBalancer — способы экспонирования сервисов
* Ingress/Ingress‑Controller — L7‑маршрутизация HTTP/gRPC
* Sidecar‑прокси (Envoy/Istio/Linkerd) — mTLS, ретраи, политика трафика

---

## 10. Диагностика и инструменты

Командная строка (Windows PowerShell):

```powershell
# HTTP/2 запрос c заголовками и таймаутом ~2 секунды
curl https://example.com/api -I --http2 --max-time 2

# Пробуем HTTP/3 (если curl и сетевой стек поддерживают)
curl https://cloudflare-quic.com/ -I --http3-only --max-time 2

# Измерение задержки DNS/подключения/передачи
curl https://example.com -w "DNS: %{time_namelookup}s Connect: %{time_connect}s TLS: %{time_appconnect}s Start: %{time_starttransfer}s Total: %{time_total}s\n" -o NUL -s

# gRPC: вызов метода через grpcurl (нужно установить отдельно)
grpcurl -plaintext localhost:50051 list
grpcurl -d '{"payment_id":"p-1"}' localhost:50051 payments.v1.PaymentService.GetStatus
```

Захват трафика: Wireshark, tcpdump/pcap (в Windows — pktmon/WinPcap/NPcap), анализ RTT, потерь, MTU.

Метрики клиента/сервиса:

* rps/qps, p50/p90/p99 latency, error rate по классам (4xx/5xx), retries_count, throttling, saturation (CPU, коннекты)

---

## 11. Практика

### 11.1 Экспоненциальный backoff с джиттером (REST)

Пример на JavaScript (fetch) с full jitter и дедлайном:

```javascript
async function fetchWithRetries(url, opts = {}) {
    const {
        method = 'GET',
            body,
            headers = {},
            attempts = 5,
            base = 100, // мс
            cap = 2000, // мс
            idempotencyKey,
            deadlineMs = 1500,
    } = opts;

    const start = Date.now();
    let lastErr;
    for (let i = 0; i < attempts; i++) {
        const remain = deadlineMs - (Date.now() - start);
        if (remain <= 0) throw lastErr || new Error('deadline exceeded');
        const controller = new AbortController();
        const t = setTimeout(() => controller.abort(), Math.min(remain, cap));
        try {
            const h = {
                ...headers
            };
            if (idempotencyKey) h['Idempotency-Key'] = idempotencyKey;
            const res = await fetch(url, {
                method,
                body,
                headers: h,
                signal: controller.signal
            });
            clearTimeout(t);
            if (res.ok) return res;
            if (res.status >= 400 && res.status < 500 && res.status !== 429) {
                throw new Error(`client error ${res.status}`);
            }
            lastErr = new Error(`server error ${res.status}`);
        } catch (e) {
            lastErr = e.name === 'AbortError' ? new Error('timeout') : e;
        }
        // backoff + full jitter
        const sleep = Math.min(cap, base * 2 ** i);
        const jitter = Math.floor(Math.random() * sleep);
        await new Promise(r => setTimeout(r, jitter));
    }
    throw lastErr || new Error('failed');
}
```

Тезисы проверки:

* Идемпотентность (или idempotency‑key)
* Дедлайн общий, а не per‑attempt таймауты бесконечно
* Джиттер обязателен

### 11.2 Экспоненциальный backoff (gRPC, Python)

```python
import grpc, random, time

def call_with_deadline(stub, request, attempts=5, base=0.1, cap=2.0, deadline=1.5):
    start = time.time()
    err = None
    for i in range(attempts):
        remain = deadline - (time.time() - start)
        if remain <= 0:
            raise err or TimeoutError('deadline exceeded')
        try:
            # gRPC дедлайн передаётся на каждый вызов
            return stub.GetStatus(request, timeout=remain)
        except grpc.RpcError as e:
            code = e.code()
            if code in (grpc.StatusCode.INVALID_ARGUMENT, grpc.StatusCode.PERMISSION_DENIED, grpc.StatusCode.UNAUTHENTICATED):
                raise  # не ретраим
            err = e
        sleep = min(cap, base * (2 ** i))
        time.sleep(random.uniform(0, sleep))  # full jitter
    raise err or RuntimeError('failed')
```

### 11.3 Подсчёт BDP и настройка клиента

Шаги:

1) Измерьте RTT до сервиса (curl -w, ping как ориентир)
2) Оцените пропускную способность (iperf3 или производный максимум из метрик)
3) BDP ≈ BW × RTT → оцените разумные буферы/оконные настройки клиента

### 11.4 Наблюдаем мультиплексирование HTTP/2/3

Идея: запросить много мелких ресурсов и посмотреть число соединений, задержку starttransfer и total.

---

## 12. Частые вопросы и анти‑паттерны

* «Увеличим таймаут в 10 раз — поможет» — нет, чаще усугубит очередь и латентность клиентов
* «Ретраим всё подряд» — без идемпотентности приведёт к дублям и некорректным состояниям
* «HTTP/2 всегда быстрее» — при потерях HOL‑блокировка TCP может бить по всем потокам; подумайте о HTTP/3
* «JSON всегда достаточно» — для высоких QPS/низкой латентности лучше Protobuf

---

## 13. Краткий глоссарий

* RTT — время туда‑обратно
* BDP — произведение пропускной способности на RTT
* HOL‑блокировка — задержка одного потока блокирует остальные
* ALPN — согласование протокола поверх TLS
* Idempotency‑Key — ключ устранения дублей на сервере

---

## 14. Домашнее задание (вариант для начинающих)

1) Реализуйте функцию ретраев с backoff+джиттером в своём языке; добавьте idempotency‑key
2) С помощью curl измерьте состав времени (DNS/Connect/TLS/Start/Total) для 3 разных хостов; объясните различия
3) Нарисуйте последовательность TCP‑handshake и TLS‑handshake (можно в mermaid) и подпишите каждый шаг

Дополнительно (по желанию):

* Сравните размер и время сериализации JSON vs Protobuf для 10k сообщений с одинаковой схемой

---

## 15. Ссылки и материалы

* RFC 9114 — HTTP/3: <https://www.rfc-editor.org/rfc/rfc9114>
* RFC 9000 — QUIC: <https://www.rfc-editor.org/rfc/rfc9000>
* gRPC Concepts: <https://grpc.io/docs/what-is-grpc/core-concepts/>
* Exponential Backoff and Jitter (AWS): <https://aws.amazon.com/ru/blogs/architecture/exponential-backoff-and-jitter/>
* Google SRE: Handling Overload: <https://sre.google/sre-book/handling-overload/>

---

Материал подготовлен для начинающих: старайтесь проверить каждую идею экспериментом (curl/grpcurl/Wireshark) и фиксировать наблюдения графиками/скриншотами.

---

## 16. Best practices для начинающих (шпаргалка с лёгким юмором)

Сетевой запрос «подвис»? Не паникуем — идём по лестнице диагностики:

1) DNS: имя резолвится куда надо? TTL не «вечный»? Split‑horizon не шутит?
2) TCP/QUIC: установилось соединение? RTT и потери в норме? Нет ли внезапных RST?
3) TLS: валиден ли сертификат, SNI правильный? Версии 1.2/1.3 поддерживаются?
4) HTTP/gRPC: статус‑коды, дедлайны, ошибки по классам 4xx/5xx; не душит ли rate limit?
5) Сервер: логи, метрики, saturation (CPU/conn), пул соединений не «в потолке»?

Таймауты и ретраи (не лечим всё увеличением таймаута):

* Задайте три таймаута: connect, read (per‑attempt), общий deadline (budget).
* Ретраим только идемпотентные операции или с idempotency‑key.
* Backoff + джиттер обязателен; cap — чтобы не ждать до следующего отпуска.
* Hedging — только для действительно безопасных операций (и с «dedupe» на сервере).

Порты и протоколы (да, UDP — тоже интернет):

* Эфемерные порты Windows по умолчанию 49152–65535 — следите за «exhaustion» при высоком QPS.
* HTTP/3 требует UDP/443; включите fallback на HTTP/2/1.1.
* gRPC чаще поверх HTTP/2; h2c (без TLS) пригодится в приватных сетях, но не в интернете.

MTU/PMTU (любим, уважаем, проверяем):

* Избегайте фрагментации: большие кадры + туннели = грусть и потери.
* Быстрый тест в Windows (подбираем без фрагментации):

```powershell
# Пакет 1472 байта + 28 байт заголовков IP+ICMP ≈ MTU 1500
ping example.com -f -l 1472
```

DNS — не просто «то, что иногда не работает»:

* Уважайте TTL, используйте кэш, не хардкодьте IP.
* Проверяйте разные резолверы: авторитетные vs локальные.
* Инструменты в Windows:

```powershell
Resolve-DnsName example.com
nslookup example.com
```

NAT и соединения:

* Держите разумные keep‑alive/idle‑timeout; переиспользуйте соединения (пулы!), но не делайте их бесконечными.
* Учитывайте TIME_WAIT/FIN_WAIT — массовое создание соединений имеет цену.

Мини‑cheatsheet PowerShell:

```powershell
Test-NetConnection example.com -Port 443
tracert example.com
Get-NetTCPConnection | Select-Object -First 5
netstat -ano | Select-String LISTENING
curl https://example.com -I --http2 --max-time 2
```

Безопасность (минимум, чтобы спать спокойно):

* TLS 1.2+ (лучше 1.3), современные шифры; проверяйте цепочку доверия.
* SNI обязателен в многосайтовых конфигурациях; по возможности mTLS внутри периметра.

И чуточку юмора напоследок:

* 127.0.0.1 — это не только дом, но и место силы.
* Если «всё падает», попробуйте выключить Nagle и включить логи (по отдельности!).
* Помните: «ещё один ретрай» — это не стратегия, а надежда.
